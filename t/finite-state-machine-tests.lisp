(in-package #:cl-automaton/tests)

(in-suite finite-state-machine-suite)

(def-test finite-state-machine-states-argument ()
  (let* ((fsm-states '(1 2 3))
	 (fsm (make-instance 'finite-state-machine :states fsm-states)))
    (dolist (state fsm-states)
      (is (has-state-p fsm state)))))

(def-test states-work-normal ()
  (let ((fsm (make-instance 'finite-state-machine)))
    (is (null (states fsm))))
  (let* ((fsm-states '(1 2 3))
	 (fsm (make-instance 'finite-state-machine :states fsm-states)))
    (is (typep (states fsm) 'list))
    (is (and (subsetp fsm-states (states fsm))
	     (subsetp (states fsm) fsm-states)))))

(def-test add-state-works-normal ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (is (= 1 (add-state fsm 1)))
    (is (has-state-p fsm 1))))

(def-test add-state-signals-error ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (signals error (add-state fsm nil))))

(def-test add-state-ignores ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (add-state fsm 1)
    (add-state fsm 1)
    (is (equal '(1) (states fsm)))))

(def-test add-state-marks-final-states ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (add-state fsm 1)
    (add-state fsm 2 t)
    (is (not (final-state-p fsm 1)))
    (is (final-state-p fsm 2))))

(def-test has-state-works-normal ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (is (not (has-state-p fsm 1)))
    (add-state fsm 1)
    (is (has-state-p fsm 1))))

(def-test advance-state-works-normal ()
  (fail "Not implemented."))

(def-test mark-sate-final-works-normal ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (add-state fsm 1)
    (mark-state-final fsm 1)
    (is (final-state-p fsm 1))))

(def-test final-states-works-normal ()
  (let ((fsm (make-instance 'finite-state-machine)))
    (is (null (final-states fsm))))
  (let* ((fsm (make-instance 'finite-state-machine)))
    (add-state fsm 1)
    (is (= 0 (length (final-states fsm))))
    (add-state fsm 2 t)
    (is (equal '(2) (final-states fsm)))))

(def-test mark-state-final-signals-error ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (signals error (mark-state-final fsm 1))
    (signals error (mark-state-final fsm nil))))

(def-test mark-state-final-ignores ()
  (let* ((fsm (make-instance 'finite-state-machine)))
    (add-state fsm 1)
    (mark-state-final fsm 1)
    (is (final-state-p fsm 1))
    (is (= 1 (length (final-states fsm))))
    (mark-state-final fsm 1)
    (is (final-state-p fsm 1))
    (is (= 1 (length (final-states fsm))))))
